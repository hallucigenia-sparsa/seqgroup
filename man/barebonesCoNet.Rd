% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/barebonesCoNet.R
\name{barebonesCoNet}
\alias{barebonesCoNet}
\title{Barebones R implementation of CoNet}
\usage{
barebonesCoNet(
  abundances,
  metadata = NULL,
  methods = c("spearman", "kld"),
  T.up = NA,
  T.down = NA,
  method.num.T = 2,
  pval.T = 0.05,
  init.edge.num = max(2, round(sqrt(nrow(abundances)))),
  min.occ = round(ncol(abundances)/3),
  keep.filtered = TRUE,
  norm = FALSE,
  stand.rows = FALSE,
  clr = FALSE,
  pval.cor = FALSE,
  permut = FALSE,
  columnwise = FALSE,
  renorm = FALSE,
  permutandboot = FALSE,
  iters = 100,
  bh = TRUE,
  pseudocount = 1e-11,
  plot = FALSE,
  verbose = FALSE
)
}
\arguments{
\item{abundances}{a matrix with taxa as rows and samples as columns}

\item{metadata}{an optional data frame with metadata items as columns, where samples are in the same order as in abundances and all items are numeric; a bipartite network will be computed}

\item{methods}{network construction methods, values can be combinations of: "pearson", "spearman", "kld", "euclid" or "bray"; note that the latter two are not defined for negative abundance values}

\item{T.up}{upper threshold for scores (when more than one network construction method is provided, init.edge.num is given and/or p-values are computed, T.up is ignored)}

\item{T.down}{lower threshold for scores (when more than one network construction method is provided, init.edge.num is given and/or p-values are computed, T.down is ignored)}

\item{method.num.T}{threshold on method number (only used when more than one method is provided)}

\item{pval.T}{threshold on p-value (only used when permut, permutandboot or pval.cor is true); if several methods are provided, only applied after merge}

\item{init.edge.num}{the number of top and bottom initial edges (init.edge.num overrides T.up/T.down, set to NA to respect T.up/T.down for a single method)}

\item{min.occ}{only keep rows with at least the given number of non-zero values (carried out before network construction)}

\item{keep.filtered}{sum all filtered rows and add the sum vector as additional row}

\item{norm}{normalize matrix (carrried out after filtering)}

\item{stand.rows}{standardize rows by dividing each entry by its corresponding row sum, applied after normalization}

\item{clr}{apply CLR transform (after filtering and normalization); if true, stand.rows is ignored and keep.filtered is set to true; pseudocount is ignored for clr (\code{\link{clr}} with omit.zeros true)}

\item{pval.cor}{compute p-values of correlations with cor.test (only valid for correlations; takes precedence over permut and permutandboot with or without renorm)}

\item{permut}{compute edge-specific p-values with a permutation test}

\item{columnwise}{permute columns instead of rows for the permutation test}

\item{renorm}{use renormalization when computing permutation distribution (only applied to correlations; cannot be combined with metadata)}

\item{permutandboot}{compute p-values from both permutation (with or without renorm) and bootstrap distribution}

\item{iters}{number of iterations for the permutation and bootstrap distributions}

\item{bh}{multiple-test-correct using Benjamini-Hochberg; if several methods are provided bh is applied to merged p-value}

\item{pseudocount}{count added to zeros prior to taking logarithm (for KLD, p-value merge and significance)}

\item{plot}{plot score or, if permut, permutandboot or pval.cor is true, p-value distribution, in both cases after thresholding}

\item{verbose}{print the number of positive and negative edges and, if permut, permutandboot or pval.cor is true, details of p-value computation}
}
\value{
igraph object with edge weights being either the absolute difference from the mean association strength, the number of supporting methods or, if permut, permutandboot or pval.cor is true, significances (-1*log10(pval)) as edge weights
}
\description{
Build a network using Pearson, Spearman, Euclidean, Kullback-Leibler and/or Bray-Curtis.
The original CoNet implementation with extended functionality is available at: \href{http://psbweb05.psb.ugent.be/conet/}{http://systemsbiology.vub.ac.be/conet}.
For export of data to the original CoNet, see \code{\link{exportToCoNet}}, for a generic network building function wrapping
barebonesCoNet and other network inference methods, see \code{\link{buildNetwork}}.
}
\details{
If renorm and permutandboot are both set to TRUE, p-value computation is equal to the ReBoot procedure implemented
in CoNet. If more than one method is selected and p-value computation is enabled, p-values are merged with Fisher's method, multiple
testing correction (if enabled) is applied on the merged p-value and the merged p-value is reported. If p-value computation is not enabled,
the method number is reported as association strength. Note that for a single dissimilarity method, weights are scaled to the absolute distance
from the mean value (for bounded Bray Curtis, this is 0.5 and for KLD, this is the mean of the observed scores), such that a larger edge weight
means a stronger association.
Edge signs (co-presence/mutual exclusion) are assigned using thresholds (T.up/T.down directly or indirectly via top/bottom initial edge number).
Co-presence (high correlation/low dissimilarity) is encoded in green, mutual exclusion (low correlation/high dissimilarity) in red and sign conflicts
(lack of agreement between methods) in gray.
When metadata are provided, a bipartite network is computed. To circumvent bipartite network computation, metadata can be appended to abundances to form a single
input matrix, but in this case, preprocessing on abundance data needs to be carried out before.
When CLR transform is applied, the Euclidean distance is the recommended measure, which according to Gloor et al. (\url{https://www.frontiersin.org/articles/10.3389/fmicb.2017.02224/full})
is equivalent to the Aitchison distance after CLR.
}
\examples{
data("ibd_taxa")
data("ibd_lineages")
ibd_genera=aggregateTaxa(ibd_taxa,lineages = ibd_lineages,taxon.level = "genus")
# only keep significant ones among the top 50 positive and negative Spearman correlations
plot(barebonesCoNet(ibd_genera,methods="spearman",init.edge.num=50,permutandboot=TRUE))
# only keep edges supported by both Bray Curtis and Spearman
plot(barebonesCoNet(ibd_genera,methods=c("spearman","bray"),init.edge.num=50))
# keep significant Euclidean distance on CLR-transformed data (samples are completed to sum to one)
g=rbind(ibd_genera,rep(1,ncol(ibd_genera))-colSums(ibd_genera))
plot(barebonesCoNet(g,clr=TRUE,methods="euclid",init.edge.num=50,permut=TRUE,columnwise=TRUE))
}
